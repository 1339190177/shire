{
  parserClass="com.phodal.shirelang.parser.ShireParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Shire"
  psiImplClassSuffix="Impl"
  psiPackage="com.phodal.shirelang.psi"
  psiImplPackage="com.phodal.shirelang.psi.impl"

  elementTypeHolderClass="com.phodal.shirelang.psi.ShireTypes"
  elementTypeClass="com.phodal.shirelang.psi.ShireElementType"
  tokenTypeClass="com.phodal.shirelang.lexer.ShireTokenType"

  extends(".*Expr") = expr

  tokens=[
    COMMENT              = 'regexp://[^\r\n]*'
    BLOCK_COMMENT        = 'regexp:/[*][^*]*[*]+([^/*][^*]*[*]+)*/'
    CODE_BLOCK_START     = "regexp:X?```[a-zA-Z]*"
    CODE_BLOCK_END       = "regexp:X?```"
    SINGLE_QUOTED_STRING = "regexp:X?'(''|[^'])*'"
    DOUBLE_QUOTED_STRING = "regexp:X?\"(\"\"|[^\"])*\""
    QUOTE_STRING         = "regexp:X?'(''|[^'])*' | X?\"(\"\"|[^\"])*\""
    CODE_BLOCK           = "CODE_BLOCK"
    CODE_CONTENT         = "CODE_CONTENT"
    IDENTIFIER           = 'regexp:[_a-zA-Z0-9]\w*'
    COLON                = "regexp:X?:"
    COMMAND_PROP         = "regexp:X?[^\\ \\t\\r\\n]*"
    SHARP                = "#"
    LINE_INFO            = "regexp:X?L[0-9]+(C[0-9]+)?(-L[0-9]+(C[0-9]+)?)?"
    FRONTMATTER_START    = "FRONTMATTER_START"
    FRONTMATTER_END      = "FRONTMATTER_END"
    IDENTIFIER           = 'regexp:[_a-zA-Z]\w*'
    LBRACKET             = "["
    RBRACKET             = "]"
    INDENT               = "INDENT"
    ARROW                = "regexp:X?->"
    OPEN_BRACE           = "{"
    CLOSE_BRACE          = "}"
    LPAREN               = "("
    RPAREN               = ")"
    NEWLINE              = "regexp:\n"
    CASE                 = "case"
    DEFAULT              = "default"
    WHEN                 = "when"
    IF                   = 'if'
    ELSE                 = 'else'
    ELSEIF               = 'elseif'
    END                  = 'end'
    ENDIF                = 'endif'
    FROM                 = 'from'
    WHERE                = 'where'
    SELECT               = 'select'

    // operators
    DASH                 = "-"
    EQEQ                 = '=='
    NEQ                  = '!='
    LT                   = '<'
    GT                   = '>'
    LTE                  = '<='
    GTE                  = '>='
    ANDAND               = '&&'
    AND                  = 'and'
    OROR                 = '||'
    DOT                  = '.'
    NOT                  = '!'
    COMMA                = ','
    PIPE                 = '|'
  ]
}

ShireFile ::= frontMatterHeader? (used | code | velocityExpr | TEXT_SEGMENT | NEWLINE | COMMENTS)*

frontMatterHeader ::= FRONTMATTER_START NEWLINE frontMatterEntries FRONTMATTER_END

frontMatterEntries ::= ((frontMatterEntry) WHITE_SPACE?)*
frontMatterEntry ::=
    "when" WHITE_SPACE? COLON WHITE_SPACE? conditionExpr NEWLINE?
    | frontMatterKey WHITE_SPACE? COLON WHITE_SPACE? (frontMatterValue | patternAction | queryStatement) NEWLINE?

frontMatterKey ::= frontMatterId | QUOTE_STRING | pattern
frontMatterValue ::= IDENTIFIER | NUMBER | QUOTE_STRING | DATE | BOOLEAN | frontMatterArray | (NEWLINE objectKeyValue)
frontMatterArray ::= LBRACKET (frontMatterValue (COMMA frontMatterValue)*) RBRACKET

frontMatterId ::= IDENTIFIER

objectKeyValue ::= (INDENT keyValue NEWLINE?)*
keyValue ::= frontMatterEntry

patternAction ::= pattern WHITE_SPACE? actionBlock
actionBlock ::=  blockStart (actionBody) blockEnd
actionBody ::= (actionExpr PIPE)* actionExpr
actionExpr ::= WHITE_SPACE? (caseBody | funcCall) WHITE_SPACE?

funcCall ::= funcName (LPAREN pipelineArgs? RPAREN)?
funcName ::= IDENTIFIER
pipelineArgs ::= (pipelineArg (COMMA pipelineArg)*)?
pipelineArg ::= NUMBER | IDENTIFIER | QUOTE_STRING

caseBody ::= CASE (WHITE_SPACE | NEWLINE)* QUOTE_STRING blockStart casePatternAction* blockEnd
casePatternAction ::= caseCondition blockStart (actionExpr PIPE)* actionExpr blockEnd
caseCondition ::= DEFAULT | pattern | QUOTE_STRING

pattern ::= PATTERN_EXPR

private blockStart ::= (WHITE_SPACE | NEWLINE)* OPEN_BRACE (WHITE_SPACE | NEWLINE)*
private blockEnd ::= (WHITE_SPACE | NEWLINE)* CLOSE_BRACE (WHITE_SPACE | NEWLINE)*

// todo
conditionExpr ::= expr
expr ::=
    logicalOrExpr
    | logicalAndExpr
    | eqComparisonExpr
    | ineqComparisonExpr
    | callExpr
    | qualRefExpr
    | simpleRefExpr
    | literalExpr
    | parenExpr
    | variableExpr

// See also:
// b/37137454: Modify databinding expression grammar to allow calls to unqualified methods
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
// https://github.com/JetBrains/Grammar-Kit/blob/master/testData/generator/ExprParser.bnf
fake refExpr ::= expr? '.' IDENTIFIER
simpleRefExpr ::= IDENTIFIER {extends=refExpr elementType=refExpr}
qualRefExpr ::= expr '.' IDENTIFIER {extends=refExpr elementType=refExpr}

logicalOrExpr ::= expr '||' expr
logicalAndExpr ::= expr ('&&' | 'and') expr
eqComparisonExpr ::= expr eqComparisonOp expr
ineqComparisonExpr ::= expr WHITE_SPACE? ineqComparisonOp WHITE_SPACE? expr
callExpr ::= refExpr '(' expressionList? ')'
expressionList ::= expr (',' expr)*
/// variable block
variableExpr ::= "{" WHITE_SPACE? expr WHITE_SPACE? "}"

literalExpr ::= literal
parenExpr ::= '(' expr ')'
// when
private eqComparisonOp ::= WHITE_SPACE? ('==' | 'and') WHITE_SPACE?
ineqComparisonOp ::= '<=' | '>=' | '<' | '>' | '!='

private literal ::= NUMBER
  | TRUE | FALSE
  | QUOTE_STRING
  | IDENTIFIER
  | "$" IDENTIFIER

used ::= (
    agentStart agentId
    | commandStart commandId (COLON COMMAND_PROP (SHARP LINE_INFO)?)?
    | variableStart (variableId | varAccess)
)

agentStart ::= '@'
commandStart ::= '/'
variableStart ::= '$'

agentId ::= IDENTIFIER
commandId ::= IDENTIFIER
variableId ::= IDENTIFIER
languageId ::= IDENTIFIER

// just make template pass success not fail
varAccess ::= OPEN_BRACE WHITE_SPACE? variableId WHITE_SPACE? (DOT WHITE_SPACE? variableId)* WHITE_SPACE? CLOSE_BRACE

code ::=  CODE_BLOCK_START (languageId | variableStart expr)? NEWLINE? code_contents? CODE_BLOCK_END?

code_contents ::= (NEWLINE | CODE_CONTENT)*

velocityExpr ::=
     '#' 'if' '(' WHITE_SPACE? variableStart? expr WHITE_SPACE?  ')'
    | '#' 'else'
    | '#' 'elseif' '(' WHITE_SPACE? variableStart? expr WHITE_SPACE? ')'
    | '#' 'end'
    | '#' 'endif'

queryStatement ::= OPEN_BRACE (NEWLINE | WHITE_SPACE)* from_clause where_clause select_clause (NEWLINE | WHITE_SPACE)* CLOSE_BRACE

from_clause ::= FROM OPEN_BRACE (NEWLINE | WHITE_SPACE)* psi_element_decl (NEWLINE | WHITE_SPACE)? CLOSE_BRACE (NEWLINE | WHITE_SPACE)*

psi_element_decl ::= psi_type variable_decl ("," psi_type variable_decl)* (NEWLINE)*

where_clause ::= WHERE OPEN_BRACE (NEWLINE)* expr (NEWLINE)* CLOSE_BRACE (NEWLINE)*

select_clause ::= SELECT OPEN_BRACE (NEWLINE)* expr (',' expr)* (NEWLINE)* CLOSE_BRACE (NEWLINE)*

psi_type ::= IDENTIFIER
variable_decl ::= IDENTIFIER
