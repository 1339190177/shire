{
  parserClass="com.phodal.shirelang.parser.ShireParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Shire"
  psiImplClassSuffix="Impl"
  psiPackage="com.phodal.shirelang.psi"
  psiImplPackage="com.phodal.shirelang.psi.impl"

  elementTypeHolderClass="com.phodal.shirelang.psi.ShireTypes"
  elementTypeClass="com.phodal.shirelang.psi.ShireElementType"
  tokenTypeClass="com.phodal.shirelang.lexer.ShireTokenType"

  extends(".*Expr") = expr

  tokens=[
    Space                = 'regexp:\s+' // this need to be commented out when generating the flex file
    COMMENT              = 'regexp://[^\r\n]*'
    BLOCK_COMMENT        = 'regexp:/[*][^*]*[*]+([^/*][^*]*[*]+)*/'
//    AGENT_START          = "@"
    AGENT_START          = "regexp:X?@"
//    COMMAND_START        = "/"
    COMMAND_START        = "regexp:X?/"
//    VARIABLE_START       = "$"
    VARIABLE_START       = "regexp:X?\\$"
    CODE_BLOCK_START     = "regexp:X?```[a-zA-Z]*"
    CODE_BLOCK_END       = "regexp:X?```"
    SINGLE_QUOTED_STRING ="regexp:X?'(''|[^'])*'"
    DOUBLE_QUOTED_STRING ="regexp:X?\"(\"\"|[^\"])*\""
    QUOTE_STRING         = "regexp:X?'(''|[^'])*' | X?\"(\"\"|[^\"])*\""
    CODE_BLOCK           = "CODE_BLOCK"
    CODE_CONTENT         = "CODE_CONTENT"
    IDENTIFIER           = "IDENTIFIER"
    LANGUAGE_ID          = "LANGUAGE_ID"
    VARIABLE_ID          = "VARIABLE_ID"
    COMMAND_ID           = "COMMAND_ID"
    AGENT_ID             = "AGENT_ID"
//    COLON                = ":"
    COLON                = "regexp:X?:"
    COMMAND_PROP         = "COMMAND_PROP"
    SHARP                = "SHARP"
//    LINE_INFO            = "LINE_INFO" => L1C2 L[0-9]+(C[0-9]+)?(-L[0-9]+(C[0-9]+)?)?
    LINE_INFO            = "regexp:X?L[0-9]+(C[0-9]+)?(-L[0-9]+(C[0-9]+)?)?"
//    FRONTMATTER_START    = "---"
    FRONTMATTER_START    = "regexp:X?---"
//    FRONTMATTER_END      = "---"
    FRONTMATTER_END      = "regexp:X?---"
    FRONTMATTER_KEY      = 'regexp:[_a-zA-Z]\w*'
    IDENTIFIER           = 'regexp:[_a-zA-Z]\w*'
//    LBRACKET             = "["
    LBRACKET             = "regexp:X?\\["
//    RBRACKET             = "RBRACKET"
    RBRACKET             = "regexp:X?\\]"
    INDENT               = "INDENT"
    ARROW                = "regexp:X?->"
    OPEN_BRACE           = "{"
    CLOSE_BRACE          = "}"
    LPAREN               = "("
    RPAREN               = ")"
    NEWLINE              = "regexp:\n"
    CASE                 = "case"
    DEFAULT              = "default"
    WHEN                 = "when"
    IF                   = 'if'
    ELSE                 = 'else'
    ELSEIF               = 'elseif'
    END                  = 'end'
    ENDIF                = 'endif'
    FROM                 = 'from'
    WHERE                = 'where'
    SELECT               = 'select'

    // operators
    DASH                 = "-"
    EQEQ                 = '=='
    NEQ                  = '!='
    LT                   = '<'
    GT                   = '>'
    LTE                  = '<='
    GTE                  = '>='
    ANDAND               = '&&'
    OROR                 = '||'
    DOT                  = '.'
    NOT                  = '!'
  ]
}

ShireFile ::= frontMatterHeader? (used | code | velocityExpr | TEXT_SEGMENT | NEWLINE | COMMENTS)*

frontMatterHeader ::= FRONTMATTER_START NEWLINE frontMatterEntries FRONTMATTER_END

frontMatterEntries ::= ((frontMatterEntry) WHITE_SPACE?)*
frontMatterEntry ::=
    "when" WHITE_SPACE? COLON WHITE_SPACE? conditionExpr NEWLINE?
    | frontMatterKey WHITE_SPACE? COLON WHITE_SPACE? (frontMatterValue | patternAction | queryStatement) NEWLINE?

frontMatterKey ::= FRONTMATTER_KEY | QUOTE_STRING | pattern
frontMatterValue ::= IDENTIFIER | NUMBER | QUOTE_STRING | DATE | BOOLEAN | frontMatterArray | (NEWLINE objectKeyValue)
frontMatterArray ::= LBRACKET (frontMatterValue (COMMA frontMatterValue)*) RBRACKET

objectKeyValue ::= (INDENT keyValue NEWLINE?)*
keyValue ::= frontMatterEntry

patternAction ::= pattern WHITE_SPACE? actionBlock
actionBlock ::=  blockStart (actionBody) blockEnd
actionBody ::= (actionExpr PIPE)* actionExpr
actionExpr ::= WHITE_SPACE? (caseBody | funcCall) WHITE_SPACE?

funcCall ::= funcName (LPAREN pipelineArgs? RPAREN)?
funcName ::= IDENTIFIER
pipelineArgs ::= (pipelineArg (COMMA pipelineArg)*)?
pipelineArg ::= NUMBER | IDENTIFIER | QUOTE_STRING

caseBody ::= CASE (WHITE_SPACE | NEWLINE)* QUOTE_STRING blockStart casePatternAction* blockEnd
casePatternAction ::= caseCondition blockStart (actionExpr PIPE)* actionExpr blockEnd
caseCondition ::= DEFAULT | pattern | QUOTE_STRING

pattern ::= PATTERN_EXPR

private blockStart ::= (WHITE_SPACE | NEWLINE)* OPEN_BRACE (WHITE_SPACE | NEWLINE)*
private blockEnd ::= (WHITE_SPACE | NEWLINE)* CLOSE_BRACE (WHITE_SPACE | NEWLINE)*

// todo
conditionExpr ::= expr
expr ::=
    logicalOrExpr
    | logicalAndExpr
    | eqComparisonExpr
    | ineqComparisonExpr
    | callExpr
    | qualRefExpr
    | simpleRefExpr
    | literalExpr
    | parenExpr
    | variableExpr

// See also:
// b/37137454: Modify databinding expression grammar to allow calls to unqualified methods
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
// https://github.com/JetBrains/Grammar-Kit/blob/master/testData/generator/ExprParser.bnf
fake refExpr ::= expr? '.' IDENTIFIER
simpleRefExpr ::= IDENTIFIER {extends=refExpr elementType=refExpr}
qualRefExpr ::= expr '.' IDENTIFIER {extends=refExpr elementType=refExpr}

logicalOrExpr ::= expr '||' expr
logicalAndExpr ::= expr '&&' expr
eqComparisonExpr ::= expr eqComparisonOp expr
ineqComparisonExpr ::= expr WHITE_SPACE? ineqComparisonOp WHITE_SPACE? expr
callExpr ::= refExpr '(' expressionList? ')'
expressionList ::= expr (',' expr)*
/// variable block
variableExpr ::= "{" WHITE_SPACE? expr WHITE_SPACE? "}"

literalExpr ::= literal
parenExpr ::= '(' expr ')'
// when
private eqComparisonOp ::= WHITE_SPACE? ('==') WHITE_SPACE?
ineqComparisonOp ::= '<=' | '>=' | '<' | '>' | '!='

private literal ::= NUMBER
  | TRUE | FALSE
  | QUOTE_STRING
  | IDENTIFIER
  | "$" IDENTIFIER

used ::= (
    AGENT_START AGENT_ID
    | COMMAND_START COMMAND_ID (COLON COMMAND_PROP (SHARP LINE_INFO)?)?
    | VARIABLE_START (varId | varAccess)
)

// just make template pass success not fail
varAccess ::= OPEN_BRACE WHITE_SPACE? varId WHITE_SPACE? (DOT WHITE_SPACE? varId)* WHITE_SPACE? CLOSE_BRACE

varId ::= VARIABLE_ID

code ::=  CODE_BLOCK_START (LANGUAGE_ID | VARIABLE_START expr)? NEWLINE? code_contents? CODE_BLOCK_END?

code_contents ::= (NEWLINE | CODE_CONTENT)*

velocityExpr ::=
     SHARP 'if' '(' WHITE_SPACE? VARIABLE_START? expr WHITE_SPACE?  ')'
    | SHARP 'else'
    | SHARP 'elseif' '(' WHITE_SPACE? VARIABLE_START? expr WHITE_SPACE? ')'
    | SHARP 'end'
    | SHARP 'endif'

queryStatement ::= OPEN_BRACE SPACE? from_clause SPACE? where_clause SPACE? select_clause SPACE CLOSE_BRACE

from_clause ::= FROM SPACE? OPEN_BRACE SPACE? psi_element_decl SPACE? CLOSE_BRACE SPACE?

psi_element_decl ::= SPACE? psi_type SPACE+ variable_decl ("," SPACE+  psi_type SPACE+  variable_decl)*

where_clause ::= WHERE SPACE? OPEN_BRACE SPACE? expr SPACE? CLOSE_BRACE SPACE?

select_clause ::= SELECT SPACE? OPEN_BRACE SPACE? expr SPACE?  CLOSE_BRACE SPACE?

psi_type ::= IDENTIFIER
variable_decl ::= IDENTIFIER
