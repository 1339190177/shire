{
  parserClass="com.phodal.shirelang.parser.ShireParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Shire"
  psiImplClassSuffix="Impl"
  psiPackage="com.phodal.shirelang.psi"
  psiImplPackage="com.phodal.shirelang.psi.impl"

  elementTypeHolderClass="com.phodal.shirelang.psi.ShireTypes"
  elementTypeClass="com.phodal.shirelang.psi.ShireElementType"
  tokenTypeClass="com.phodal.shirelang.lexer.ShireTokenType"

  extends(".*Expr") = expr

  tokens=[
    AGENT_START        = "AGENT_START"
    COMMAND_START      = "COMMAND_START"
    VARIABLE_START     = "VARIABLE_START"
    SYSTEM_START       = "SYSTEM_START"
    CODE_BLOCK_START   = "CODE_BLOCK_START"
    CODE_BLOCK_END     = "CODE_BLOCK_END"
    CODE_BLOCK         = "CODE_BLOCK"
    CODE_CONTENT       = "CODE_CONTENT"
    IDENTIFIER         = "IDENTIFIER"
    LANGUAGE_ID        = "LANGUAGE_ID"
    VARIABLE_ID        = "VARIABLE_ID"
    COMMAND_ID         = "COMMAND_ID"
    AGENT_ID           = "AGENT_ID"
    SYSTEM_ID          = "SYSTEM_ID"
    COLON              = "COLON"
    COMMAND_PROP       = "COMMAND_PROP"
    SHARP              = "SHARP"
    LINE_INFO          = "LINE_INFO"
    FRONTMATTER_START  = "FRONTMATTER_START"
    FRONTMATTER_END    = "FRONTMATTER_END"
    FRONTMATTER_KEY    = "FRONTMATTER_KEY"
    LBRACKET           = "LBRACKET"
    RBRACKET           = "RBRACKET"
    INDENT             = "INDENT"
    ARROW              = "ARROW"
    OPEN_BRACE         = "{"
    CLOSE_BRACE        = "}"
    LPAREN             = "("
    RPAREN             = ")"
    CASE               = "case"
    DEFAULT            = "default"
    WHEN               = "when"
    IF                 = 'if'
    ELSE               = 'else'
    ELSEIF             = 'elseif'
    END                = 'end'
    ENDIF              = 'endif'

    // operators
    DASH               = "-"
    EQEQ               = '=='
    NEQ                = '!='
    LT                 = '<'
    GT                 = '>'
    LTE                = '<='
    GTE                = '>='
    ANDAND             = '&&'
    OROR               = '||'
    DOT                = '.'
    NOT                = '!'
  ]
}

ShireFile ::= frontMatterHeader? (used | code | TEXT_SEGMENT | NEWLINE | COMMENTS)*

frontMatterHeader ::= FRONTMATTER_START NEWLINE frontMatterEntries FRONTMATTER_END

frontMatterEntries ::= ((frontMatterEntry) WHITE_SPACE?)*
frontMatterEntry ::=
    "when" WHITE_SPACE? COLON WHITE_SPACE? conditionExpr NEWLINE?
    | frontMatterKey WHITE_SPACE? COLON WHITE_SPACE? (frontMatterValue | patternAction) NEWLINE?

frontMatterKey ::= FRONTMATTER_KEY | QUOTE_STRING
frontMatterValue ::= IDENTIFIER | NUMBER | QUOTE_STRING | DATE | BOOLEAN | frontMatterArray | (NEWLINE objectKeyValue)
frontMatterArray ::= LBRACKET (frontMatterValue (COMMA frontMatterValue)*) RBRACKET

objectKeyValue ::= (INDENT keyValue NEWLINE?)*
keyValue ::= frontMatterEntry

patternAction ::= pattern WHITE_SPACE? actionBlock
actionBlock ::=  blockStart (actionBody) blockEnd
actionBody ::= (actionExpr PIPE)* actionExpr
actionExpr ::= WHITE_SPACE? (caseBody | funcCall) WHITE_SPACE?

funcCall ::= funcName (LPAREN pipelineArgs? RPAREN)?
funcName ::= IDENTIFIER
pipelineArgs ::= (pipelineArg (COMMA pipelineArg)*)?
pipelineArg ::= NUMBER | IDENTIFIER | QUOTE_STRING

caseBody ::= CASE (WHITE_SPACE | NEWLINE)* QUOTE_STRING blockStart casePatternAction* blockEnd
casePatternAction ::= caseCondition blockStart (actionExpr PIPE)* actionExpr blockEnd
caseCondition ::= DEFAULT | pattern | QUOTE_STRING

pattern ::= PATTERN_EXPR

private blockStart ::= (WHITE_SPACE | NEWLINE)* OPEN_BRACE (WHITE_SPACE | NEWLINE)*
private blockEnd ::= (WHITE_SPACE | NEWLINE)* CLOSE_BRACE (WHITE_SPACE | NEWLINE)*

// todo
conditionExpr ::= expr
expr ::=
    logicalOrExpr
    | logicalAndExpr
    | eqComparisonExpr
    | ineqComparisonExpr
    | callExpr
    | qualRefExpr
    | simpleRefExpr
    | literalExpr
    | parenExpr

// See also:
// b/37137454: Modify databinding expression grammar to allow calls to unqualified methods
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
// https://github.com/JetBrains/Grammar-Kit/blob/master/testData/generator/ExprParser.bnf
fake refExpr ::= expr? '.' IDENTIFIER
simpleRefExpr ::= IDENTIFIER {extends=refExpr elementType=refExpr}
qualRefExpr ::= expr '.' IDENTIFIER {extends=refExpr elementType=refExpr}

logicalOrExpr ::= expr '||' expr
logicalAndExpr ::= expr '&&' expr
eqComparisonExpr ::= expr eqComparisonOp expr
ineqComparisonExpr ::= expr ineqComparisonOp expr
callExpr ::= refExpr '(' expressionList? ')'
expressionList ::= expr (',' expr)*

literalExpr ::= literal
parenExpr ::= '(' expr ')'
// when
private eqComparisonOp ::= '==' | '!='
private ineqComparisonOp ::= '<=' | '>=' | '<' | '>'

private literal ::= NUMBER
  | TRUE | FALSE
  | QUOTE_STRING
  | IDENTIFIER
  | "$" IDENTIFIER

used ::= (
    AGENT_START AGENT_ID
    | COMMAND_START COMMAND_ID (COLON COMMAND_PROP (SHARP LINE_INFO)?)?
    | VARIABLE_START (VARIABLE_ID | varAccess)
    | SYSTEM_START (velocityExpr | SYSTEM_ID COLON NUMBER)
)

// just make template pass success not fail
varAccess ::= OPEN_BRACE WHITE_SPACE? VARIABLE_ID WHITE_SPACE? (DOT WHITE_SPACE? VARIABLE_ID)* WHITE_SPACE? CLOSE_BRACE

code ::=  CODE_BLOCK_START LANGUAGE_ID? NEWLINE? code_contents? CODE_BLOCK_END?

code_contents ::= (NEWLINE | CODE_CONTENT)*

velocityExpr ::=
     'if' expr
    | 'else'
    | 'elseif' expr
    | 'end'
    | 'endif'
