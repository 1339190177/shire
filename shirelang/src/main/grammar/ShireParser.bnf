{
  parserClass="com.phodal.shirelang.parser.ShireParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Shire"
  psiImplClassSuffix="Impl"
  psiPackage="com.phodal.shirelang.psi"
  psiImplPackage="com.phodal.shirelang.psi.impl"

  elementTypeHolderClass="com.phodal.shirelang.psi.ShireTypes"
  elementTypeClass="com.phodal.shirelang.psi.ShireElementType"
  tokenTypeClass="com.phodal.shirelang.lexer.ShireTokenType"

  extends(".*Expr") = expr

  tokens=[
    COMMENT              = 'regexp://[^\r\n]*'
    BLOCK_COMMENT        = 'regexp:/[*][^*]*[*]+([^/*][^*]*[*]+)*/'
    CODE_BLOCK_START     = "regexp:X?```[a-zA-Z]*"
    CODE_BLOCK_END       = "regexp:X?```"
    SINGLE_QUOTED_STRING = "regexp:X?'(''|[^'])*'"
    DOUBLE_QUOTED_STRING = "regexp:X?\"(\"\"|[^\"])*\""
    QUOTE_STRING         = "regexp:X?'(''|[^'])*' | X?\"(\"\"|[^\"])*\""
    CODE_BLOCK           = "CODE_BLOCK"
    CODE_CONTENT         = "CODE_CONTENT"
    IDENTIFIER           = 'regexp:[_a-zA-Z0-9]\w*'
    COLON                = "regexp:X?:"
    COMMAND_PROP         = "regexp:X?[^\\ \\t\\r\\n]*"
    SHARP                = "#"
    LINE_INFO            = "regexp:X?L[0-9]+(C[0-9]+)?(-L[0-9]+(C[0-9]+)?)?"
    FRONTMATTER_START    = "FRONTMATTER_START"
    FRONTMATTER_END      = "FRONTMATTER_END"
    IDENTIFIER           = 'regexp:[_a-zA-Z]\w*'
    LBRACKET             = "["
    RBRACKET             = "]"
    INDENT               = "INDENT"
    ARROW                = "regexp:X?->"
    OPEN_BRACE           = "{"
    CLOSE_BRACE          = "}"
    LPAREN               = "("
    RPAREN               = ")"
    NEWLINE              = "regexp:\n"
    CASE                 = "case"
    DEFAULT              = "default"
    WHEN                 = "when"
    IF                   = 'if'
    ELSE                 = 'else'
    ELSEIF               = 'elseif'
    END                  = 'end'
    ENDIF                = 'endif'
    FROM                 = 'from'
    WHERE                = 'where'
    SELECT               = 'select'

    // operators
    DASH                 = "-"
    EQEQ                 = '=='
    NEQ                  = '!='
    LT                   = '<'
    GT                   = '>'
    LTE                  = '<='
    GTE                  = '>='
    ANDAND               = '&&'
    AND                  = 'and'
    OROR                 = '||'
    DOT                  = '.'
    NOT                  = '!'
    COMMA                = ','
    PIPE                 = '|'
  ]
}

ShireFile ::= frontMatterHeader? (used | code | velocityExpr | TEXT_SEGMENT | NEWLINE | COMMENTS)*

frontMatterHeader ::= FRONTMATTER_START NEWLINE frontMatterEntries FRONTMATTER_END

frontMatterEntries ::= frontMatterEntry*
frontMatterEntry ::=
    "when" COLON conditionExpr NEWLINE?
    | frontMatterKey COLON (frontMatterValue | patternAction | queryStatement) NEWLINE?

frontMatterKey ::= frontMatterId | QUOTE_STRING | pattern
frontMatterValue ::= IDENTIFIER | NUMBER | QUOTE_STRING | DATE | BOOLEAN | frontMatterArray | (NEWLINE objectKeyValue)
frontMatterArray ::= "[" (frontMatterValue (COMMA frontMatterValue)*) "]"

frontMatterId ::= IDENTIFIER

objectKeyValue ::= (INDENT keyValue NEWLINE?)*
keyValue ::= frontMatterEntry

patternAction ::= pattern actionBlock
actionBlock ::=  blockStart (actionBody) blockEnd
actionBody ::= (actionExpr PIPE)* actionExpr
actionExpr ::= caseBody | funcCall

funcCall ::= funcName ("(" pipelineArgs? ")")?
funcName ::= IDENTIFIER
pipelineArgs ::= (pipelineArg (COMMA pipelineArg)*)?
pipelineArg ::= NUMBER | IDENTIFIER | QUOTE_STRING

caseBody ::= CASE NEWLINE* QUOTE_STRING blockStart casePatternAction* blockEnd
casePatternAction ::= caseCondition blockStart (actionExpr PIPE)* actionExpr blockEnd
caseCondition ::= DEFAULT | pattern | QUOTE_STRING

pattern ::= PATTERN_EXPR

// todo
conditionExpr ::= expr
expr ::=
    logicalOrExpr
    | logicalAndExpr
    | eqComparisonExpr
    | ineqComparisonExpr
    | callExpr
    | qualRefExpr
    | simpleRefExpr
    | literalExpr
    | parenExpr
    | variableExpr

// See also:
// b/37137454: Modify databinding expression grammar to allow calls to unqualified methods
// https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
// https://github.com/JetBrains/Grammar-Kit/blob/master/testData/generator/ExprParser.bnf
fake refExpr ::= expr? '.' IDENTIFIER
simpleRefExpr ::= IDENTIFIER {extends=refExpr elementType=refExpr}
qualRefExpr ::= expr '.' IDENTIFIER {extends=refExpr elementType=refExpr}

logicalOrExpr ::= expr '||' expr
logicalAndExpr ::= expr ('&&' | 'and') expr
eqComparisonExpr ::= expr eqComparisonOp expr
ineqComparisonExpr ::= expr ineqComparisonOp expr
callExpr ::= refExpr '(' expressionList? ')'
expressionList ::= expr (',' expr)*
/// variable block
variableExpr ::= "{" expr "}"

literalExpr ::= literal
parenExpr ::= '(' expr ')'
// when
private eqComparisonOp ::= '==' | 'and' | 'AND'
ineqComparisonOp ::= '<=' | '>=' | '<' | '>' | '!='

private literal ::= NUMBER
  | TRUE | FALSE
  | QUOTE_STRING
  | IDENTIFIER
  | "$" IDENTIFIER

used ::= (
    agentStart agentId
    | commandStart commandId (COLON COMMAND_PROP (SHARP LINE_INFO)?)?
    | variableStart (variableId | varAccess)
)

agentStart ::= '@'
commandStart ::= '/'
variableStart ::= '$'

agentId ::= IDENTIFIER
commandId ::= IDENTIFIER
variableId ::= IDENTIFIER
languageId ::= IDENTIFIER

// just make template pass success not fail
varAccess ::= OPEN_BRACE variableId (DOT variableId)* CLOSE_BRACE

code ::=  CODE_BLOCK_START (languageId | variableStart expr)? NEWLINE? code_contents? CODE_BLOCK_END?

code_contents ::= (NEWLINE | CODE_CONTENT)*

velocityExpr ::=
     '#' 'if' '('variableStart? expr ')'
    | '#' 'else'
    | '#' 'elseif' '(' variableStart? expr ')'
    | '#' 'end'
    | '#' 'endif'

queryStatement ::= blockStart from_clause where_clause select_clause blockEnd

from_clause ::= FROM blockStart psi_element_decl blockEnd

psi_element_decl ::= psi_type variable_decl ("," psi_type variable_decl)* (NEWLINE)*

where_clause ::= WHERE blockStart expr blockEnd

select_clause ::= SELECT blockStart expr (',' expr)* blockEnd

private blockStart ::= NEWLINE* "{" NEWLINE*
private blockEnd ::= NEWLINE* "}" NEWLINE*

psi_type ::= IDENTIFIER
variable_decl ::= IDENTIFIER
